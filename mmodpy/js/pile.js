//This Javascript creates a pile to use in CSP tests.
//The csv file used by the script is generated by another excel file.
//Code is based on Richard Sturt's soil block script.
//It still needs improvements in terms of node, part, element and material IDs.
//Ulas Cilingir - 22/12/2015
//
//
//SShah - 18/02/2016: 
//minor modifications to material properties (assumed SI units)
//changed load ramp and term time to 2s / 4s. 
//
//

Message("This is Pile.js - UC");

var colname = new Array();
colname[0] = "PILE_NODE";
colname[1] = "DEPTH";
colname[2] = "PARTID";
colname[3] = "KVCON";
colname[4] = "KVCU";
colname[5] = "KVSX";
colname[6] = "KVSY";
colname[7] = "KVSZ";
colname[8] = "VSTFAC";
colname[9] = "VHYPER";
colname[10] = "VLC";
colname[11] = "LCCU";

//////////////////////////////////////////////////////////////////////////////////////////
//
//  Initialize

//////////////////////////////////////////////////////////////////////////////////////////
//  Open the csv file, returning from the function if unable to open it
var strInputFile = Window.GetFilename("Select file","Select CSV file for the pile","csv");
if (!strInputFile) Exit();
if ( File.IsFile(strInputFile) )  var fInputFile = new File(strInputFile, File.READ);
else ErrorTermination("Cannot find or open csv file for the pile: " + strInputFile);
//////////////////////////////////////////////////////////////////////////////////////////
//
//  Read data from file
var strWords = new Array();
var strLine;
var layer_data = new Array();

var first = 1;
var num_param = 0;				// Number of fields in csv file
var max_param = -1;
var num_layers = 0;         	// Number of soil layers

var column_param = new Array(); // Which column for each parameter 
                                // column_param[i] = k means store the i'th column as parameter k
var param_column = new Array(); // Which parameter is in each column
                                // param_column[k] = i means the k'th parameter is in the i'th column
								  
//Pile will always be created at X=0.0m and Y=0.0m.
var pile_material = "Concrete";
var pile_diameter = 0.5;
var pile_geometry = "Circular";
var astiffb = 1e7;
var astiffs = 1e4;
var kbcon = 1;
var convert_to_pa = "No";
var qz_sfo = 1000;
var qz_sfa = pile_diameter;
var x_coord = 0;
var y_coord = 0;
var max_displacement = 0.05;

// Loop over each line
while ( (strLine = fInputFile.ReadLongLine()) != undefined )
{
	Message("Line from csv file: "+strLine);
	strWords = strLine.split(",");	// strWords is an array of strings cut
									// from the line using comma as a delimiter
	//If first character is a '$', read comments

    if (strWords[0] != undefined && strWords[0].search(/^\$/) == 0)
    { 
        if (strWords[1] != undefined)
        {
		//Check which variable is being set, converting it to lower case
			strVariable = strWords[0].substring(1, strWords[0].length);
            var lowercase = strVariable.toLowerCase();
            Message("Word0 = " + strWords[0]);
            Message("Word1 = " + strWords[1]);
	      
			switch(lowercase)
            {
			case "pile_material":          
				{ 
				var pile_material   = strWords[1];
				Message("Found pile_material   = " + pile_material  );                 
				break; 
			}
            case "pile_diameter":          
				{ 
				var pile_diameter   = parseFloat(strWords[1]);
				Message("Found pile_diameter   = " + pile_diameter  );                 
				break; 
			}
            case "pile_geometry":          
			{ 
			  var pile_geometry   = strWords[1];
			  Message("Found pile_geometry   = " + pile_geometry  );                 
			  break; 
			}
            case "astiffb":          
			{ 
			  var astiffb   = parseFloat(strWords[1]);
			  Message("Found astiffb   = " + astiffb  );                 
			  break; 
			}
            case "convert_to_pa":          
			{ 
			  var convert_to_pa   = strWords[1];
			  Message("Found convert_to_pa   = " + convert_to_pa  );                 
			  break; 
			}
            case "qz_sfo":          
			{ 
			  var qz_sfo   = parseFloat(strWords[1]);
			  Message("Found qz_sfo   = " + qz_sfo  );                 
			  break; 
			}
            case "qz_sfa":          
			{ 
			  var qz_sfa   = parseFloat(strWords[1]);
			  Message("Found qz_sfa   = " + qz_sfa  );                 
			  break; 
			}
            case "x_coord":          
			{ 
			  var x_coord   = parseFloat(strWords[1]);
			  Message("Found X - Coordinate   = " + x_coord  );                 
			  break; 
			}
            case "y_coord":          
			{ 
			  var y_coord   = parseFloat(strWords[1]);
			  Message("Found Y - Coordinate   = " + y_coord  );                 
			  break; 
			}
            case "max_displacement":          
			{ 
			  var max_displacement   = parseFloat(strWords[1]);
			  Message("Found max_displacement   = " + max_displacement  );                 
			  break; 
			}
			default: if (lowercase && lowercase !=" ") ErrorTermination("Cannot recognise variable: " + strLine);
            }
        }
    }
////////////////////////////////////////////////////////////////////////////
//    Read column headers
//
    else if (first)    
    {
	    first = 0;
	    for (var i=0; i<strWords.length; i++)
	    {
            var uppercase = strWords[i].toUpperCase();
		    var found = 0;
		    for (var k=0; k<colname.length; k++)
		    {
			    if (uppercase == colname[k])
			    {
					column_param[i] = k;            
			      	param_column[k] = i;            
			      	found = 1; 
			      	num_param++;
					max_param = Math.max(k,max_param);
			      	var prt_i = i+1;
			      	Message("Found header "+strWords[i]+" in column " + prt_i);
			    }
		    }

		    if (!found) 
		      {
       				var answer = Window.Question("Question","Cannot recognise column header: "+strWords[i]
						                       +"\nIgnore this column?",Window.YES|Window.NO);
			      if (answer==Window.NO) ErrorTermination("Unrecognised column");
		      }
	      }
	      Message("Found "+num_param+" columns");
      }
////////////////////////////////////////////////////////////////////////////
//    Read and process a line of data
//
      else if (num_param>1 && strWords.length>=num_param)	//  Normal line of data
      {
	      if (param_column[0]==-1 && param_column[1]==-1) ErrorTermination("Must define PILE_NODE and DEPTH");
		  if (param_column[0]==-1 && param_column[1]!=-1) ErrorTermination("PILE_NODE data is missing");
		  if (param_column[0]!=-1 && param_column[1]==-1) ErrorTermination("DEPTH data is missing");
	      var param_list = new Array();						//  Store parameter values
	      for (i=0; i<num_param; i++) param_list[column_param[i]] = parseFloat(strWords[i]);
	      layer_data.push(param_list);
	      num_layers++;
      }
      else
      {
	      if (first) ErrorTermination("Error - Header line not found");
	      ErrorTermination("Error - invalid line: " + strLine);
      }
}

// Echo the data to dialog box
Message("num_param = "+num_param);
for (k=0; k<max_param+1; k++) Message("Param "+k+" Column="+param_column[k]);
for (k=0; k<num_param; k++) Message("Column "+k+" Param="+column_param[k]);

for (var i=0; i<=max_param; i++)
{
	if (param_column[i]>-1)
	{
		Message("Layer "+colname[i]);
		for (var k=0; k<num_layers; k++) Message(k+1 + "     " + layer_data[k][i]);
	}
}
fInputFile.Close();

OKToContinue();

//var answer = ScratchModel();
var m = Model.First();
if (m === null){
	var m = new Model();
	Message("This is a scratch model.");
} else
{
	answer = 0;
	Message("This is an existing model.");
}
// Select or create model;           
//if (answer!=0) var m = new Model();
//else var m = Model.Select("Select model");

var flag = AllocateFlag();
m.SetFlag(flag);
//m.PropagateFlag(flag);

//   Find z-coord of soil surface, max node ID, etc
var n = Node.First(m);
var found = 0;
var nid_next = 1;
var nid_min = 999999999;
var nid_max = -1;
var num_flagged = 0;

while (n)
{
	nid_next = Math.max(nid_next, n.nid+1);
	if (n.Flagged(flag)) 
	{
		found = 1;
		z_surface = n.z;
		nid_min = Math.min(n.nid,nid_min);
		nid_max = Math.max(n.nid,nid_max);
		num_flagged++;
	}
	n = n.Next();
}

//  create new nodes
if (answer!=0){
	var n2 = new Node(m,1,0,0,-layer_data[0][1]);
	n = Node.First(m);
	var n2 = new Node(m,2,-1,0,-layer_data[0][1]);
	n = n.Next();
	var top_node_id = 1;
	for (i=1; i<num_layers; i++)
	{
		// Creating new nodes for the piles
		Message(layer_data[i][1]);
		var n2 = new Node(m,n.nid+1,x_coord,y_coord,-layer_data[i][1]);
		n = n.Next();
		var n2 = new Node(m,n.nid+1,x_coord - 0.5,y_coord,-layer_data[i][1]);
		n = n.Next();
	}
}
else {
	n = Node.Last(m)
	var top_node_id = n.nid + 1;
	for (i=0; i<num_layers; i++)
	{
		// Creating new nodes for the piles
		var n2 = new Node(m,n.nid+1,x_coord,y_coord,-layer_data[i][1]);
		n = n.Next();		
		var n2 = new Node(m,n.nid+1,x_coord - 0.5,y_coord,-layer_data[i][1]);
		n = n.Next();
	}
}
// create new beam section and a null beam section
var sid_next = 1;
var s = Section.First(m);
var ns_flagged = 0;
var sid_min = 999999999;
var sid_max = -1;
while(s)
{
	sid_next = Math.max(sid_next, s.secid);
	if (s.Flagged(flag)) 
	{
		ns_flagged++;
		sid_min = Math.min(sid_min,s.secid);
		sid_max = Math.max(sid_max,s.secid);
	}
	s = s.Next();
}

if (answer!=0){
	var s = new Section(m,n.nid+1000,Section.BEAM,'Pile Section');
	s.elform = 2;
	s.qr = 2.0;
	if ((pile_geometry.toUpperCase()=="SQUARE")||(pile_geometry.toUpperCase()=="RECTANGULAR")){
		s.shrf = 0.833;
		s.stype="SECTION_11";
		s.d1	=	pile_diameter;
		s.d2	=	pile_diameter;
	}
	else{
		s.stype="SECTION_08";
		s.d1	=	pile_diameter / 2;
	}
	var beam_secid = s.secid;
	s = s.Next();
}
else {
	var s = new Section(m,sid_max+1,Section.BEAM,'Pile Section');
	s.elform = 2;
	s.qr = 2.0;
	if ((pile_geometry.toUpperCase()=="SQUARE")||(pile_geometry.toUpperCase()=="RECTANGULAR")){
		s.shrf = 0.833;
		s.stype="SECTION_11";
		s.d1	=	pile_diameter;
		s.d2	=	pile_diameter;
	}
	else{
		s.stype="SECTION_08";
		s.d1	=	pile_diameter / 2;
	}
	var beam_secid = s.secid;
	s = s.Next();
}

// null beam section
var s = new Section(m,beam_secid+1,Section.BEAM,'Null Beam Section');
s.elform = 6;
s.qr = 2.0;
s.vol = 1e-12;
s.iner = 1e-12;
var null_beam_secid = s.secid;
s = s.Next();
	
// create new material
var mid_next = 1;
var mat = Material.First(m);
var nm_flagged = 0;
var mid_min = 999999999;
var mid_max = -1;
while(mat)
{
	mid_next = Math.max(mid_next, mat.mid);
	if (mat.Flagged(flag)) 
	{
		nm_flagged++;
		mid_min = Math.min(mid_min,mat.mid);
		mid_max = Math.max(mid_max,mat.mid);
	}
	mat = mat.Next();
}

if (answer!=0){
	var mat = new Material(m,n.nid+50000,'ELASTIC');
	if(pile_material.toUpperCase()=="STEEL"){
		mat.SetPropertyByName("RO", 7850.0);
		mat.SetPropertyByName("E", 2.1E11);
		mat.SetPropertyByName("PR", 0.3);
	}
	else{
		mat.SetPropertyByName("RO", 2400.0);
		mat.SetPropertyByName("E", 2.8E10);
		mat.SetPropertyByName("PR", 0.2);
	}
	var beam_mid = mat.mid;
	mat = mat.Next();
}
else {
	var mat = new Material(m,mid_max+1,'ELASTIC');
	if(pile_material.toUpperCase()=="STEEL"){
		mat.SetPropertyByName("RO", 7850.0);
		mat.SetPropertyByName("E", 2.1E11);
		mat.SetPropertyByName("PR", 0.3);
	}
	else{
		mat.SetPropertyByName("RO", 2400.0);
		mat.SetPropertyByName("E", 2.8E10);
		mat.SetPropertyByName("PR", 0.2);
	}
	var beam_mid = mat.mid;
	mat = mat.Next();
}

// null beam material
var mat = new Material(m,beam_mid+1,'NULL');
mat.SetPropertyByName("RO", 1);
var null_beam_mid = mat.mid;
mat = mat.Next();

// create a new part for the beam
var pid_next = 1;
var p = Part.First(m);
var np_flagged = 0;
var pid_min = 999999999;
var pid_max = -1;

while(p)
{
	pid_next = Math.max(pid_next, p.pid);
	if (p.Flagged(flag)) 
	{
		np_flagged++;
		pid_min = Math.min(pid_min,p.pid);
		pid_max = Math.max(pid_max,p.pid);
	}
	p = p.Next();
}
if (answer!=0){
	var p = new Part(m,n.nid+99000,beam_secid, beam_mid, 'Pile Part');
	var beam_pid = p.pid;
	p = p.Next();
}
else {
	var p = new Part(m,pid_max+1,beam_secid, beam_mid, 'Pile Part');
	var beam_pid = p.pid;
	p = p.Next();
}

//create two new parts for the null beam
var p = new Part(m,beam_pid + 1,null_beam_secid, null_beam_mid, 'Null Beam Part 1');
var null_beam_pid1 = p.pid;
p = p.Next();
var p = new Part(m,null_beam_pid1 + 1,null_beam_secid, null_beam_mid, 'Null Beam Part 2');
var null_beam_pid2 = p.pid;
p = p.Next();

// create new beams
var bid_next = 1;
var b = Beam.First(m);
var nb_flagged = 0;
var bid_min = 999999999;
var bid_max = -1;
while(b)
{
	bid_next = Math.max(bid_next, b.eid);
	if (b.Flagged(flag)) 
	{
		nb_flagged++;
		bid_min = Math.min(bid_min,b.eid);
		bid_max = Math.max(bid_max,b.eid);
	}
	b = b.Next();
}

n = Node.Last(m);
p = Part.Last(m);

var no_of_beams = num_layers - 1;

if (answer != 0){
	for (i=1;i < no_of_beams+1; i++){
		var b = new Beam(m,n.nid + 999000 + i,beam_pid, nid_max + 2*i, nid_max + 2*i + 2, nid_max + 2*i + 1);
		b = b.Next();
	}	
}
else {	
	for (i=1;i < no_of_beams+1;i++){
		var b = new Beam(m,bid_max + 1 + i,beam_pid, nid_max + 2*i - 1, nid_max + 2*i + 1, nid_max + 2*i);
		b = b.Next();
	}
}

// create Q-z curve
var qz_curve = new Curve(Curve.CURVE, m, p.pid + 1, 0, qz_sfa, qz_sfo);
qz_curve.heading = "Q-z Curve";
qz_curve.AddPoint(0,0);
qz_curve.AddPoint(2e-3,0.25);
qz_curve.AddPoint(1.3e-2,0.5);
qz_curve.AddPoint(4.2e-2,0.75);
qz_curve.AddPoint(7.3e-2,0.9);
qz_curve.AddPoint(0.1,1.0);
qz_curve.AddPoint(0.2,1.0);

// create LCCU curve
var lccu_curve = new Curve(Curve.CURVE, m, p.pid + 2);
lccu_curve.heading = "LCCU Curve";
for(i=0;i < num_layers;i++){
lccu_curve.AddPoint(-layer_data[num_layers-i-1][1],layer_data[num_layers-i-1][11]);
}
if (convert_to_pa.toLowerCase() == "yes"){
	lccu_curve.sfo = 1000;
}

// create displacement curve
var displacement_curve = new Curve(Curve.CURVE, m, p.pid + 3);
displacement_curve.heading = "Displacement Curve";
displacement_curve.AddPoint(0,0);
displacement_curve.AddPoint(2,1);
displacement_curve.AddPoint(4,1);
displacement_curve.sfo = -max_displacement;

// create a pile part set to use in CSP
var pile_set = new Set(m,p.pid + 4,Set.PART,"Pile Set for CSP");
pile_set.Add(beam_pid);

// write CSP parameters to an include file in freedom format

if (convert_to_pa.toLowerCase()=="yes"){
	astiffs = astiffs * 1000;
	astiffb = astiffb * 1000;
	kbcon = kbcon * 1000;
}
f = new File("./CSP.key", File.WRITE);     // Open temporary file
f.Writeln("*KEYWORD");                       // Write set keyword data to file
f.Writeln("*CONSTRAINED_SOIL_PILE");
f.Writeln(pile_set.sid + "," + pile_diameter + "," + "0" + "," + null_beam_pid1 + "," + null_beam_pid2 + "," + "1" + "," + "24" + "," + "0");
for(i=0;i < num_layers;i++){
	f.Writeln(layer_data[i][2] + "," + "0.0" + "," + "0.0" + "," + lccu_curve.lcid + "," + astiffs.toPrecision(3) + "," + "0.0" + "," + astiffb.toPrecision(3) + "," + "0.0");
	if (i==num_layers-1){
		f.Writeln(kbcon + "," + "0.0" + "," + "0.0" + "," + "0.0" + "," + "0.0" + "," + "0.0" + "," + "0.0" + "," + qz_curve.lcid);
	}
	else{
		f.Writeln("0.0" + "," + "1.0" + "," + "0.0" + "," + "0.0" + "," + "0.0" + "," + "1.0" + "," + "0.0" + "," + "0");	
	}
	if (convert_to_pa.toLowerCase()=="yes"){
		layer_data[i][3] = layer_data[i][3]*1000;
	}
	f.Writeln(layer_data[i][3] + "," + layer_data[i][4] + "," + layer_data[i][5] + "," + layer_data[i][6] + "," + layer_data[i][7] + "," + layer_data[i][8] + "," + layer_data[i][9] + "," + layer_data[i][10]);
	f.Writeln("0.0" + "," + "9.0" + "," + "0.0" + "," + "0.0" + "," + "0.0" + "," + "100.0" + "," + "0.0" + "," + "0");
	f.Writeln("$$");
}
f.Writeln("*END");
f.Close();                                  	    // Close temporary file
m.Import("CSP.key");                       // Import data from file into model
File.Delete("./CSP.key");                  // Delete temporary file

//Create a prescribed motion at the pile head
var presmot = new PrescribedMotion(m, top_node_id, 3, 2, displacement_curve.lcid, PrescribedMotion.NODE);

//Control termination
m.control.termination.exists = true;
m.control.termination.endtim = 4;

//Update the graphics in model
m.UpdateGraphics();

//View wireframe
View.Li();

//View YZ plane
View.Show(View.YZ);

// Autoscale view
View.Ac();

/////////////////////////////////////////////////////////////////////////////
//
function Termination(line)
{
	if (fInputFile) fInputFile.Close();
	if (m) m.UpdateGraphics();
	Message(line);
	//if (flag) ReturnFlag(flag);
	Exit();
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
//
function ErrorTermination(line)
{
	Window.Error("Error",line,Window.OK);
	Termination(line);
}

///////////////////////////////////////////////////////
//
function OKToContinue()
{
	var answer = Window.Question("Question","OK to continue?", Window.YES | Window.NO | Window.NONMODAL);
	if (answer==Window.NO) Exit();
}

///////////////////////////////////////////////////////
//
function ScratchModel()
{
	var answer = Window.Question("Question","Is this a Scratch Model?", Window.YES | Window.NO | Window.NONMODAL);
	if (answer==Window.NO) answer = 0;
	return answer;
}
